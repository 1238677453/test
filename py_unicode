{$mode objfpc}
{$H+}
{$inline on}
{$PACKRECORDS C}
{$MACRO ON}
{$MODESWITCH ADVANCEDRECORDS}
{$BITPACKING ON}
{$MODESWITCH ALLOWINLINE}

unit py_unicode;

interface

//{$DEFINE Py_GIL_DISABLED}

uses
  PythonEngine,
  ctypes;

type
  Py_ssize_t = nativeint;
  uint8_t = byte;
  uint16_t = word;
  uint32_t = cardinal;

  PPy_ssize_t = ^Py_ssize_t;
  Py_hash_t = Py_ssize_t;
  Py_UCS1 = uint8_t;
  PPy_UCS1 = ^Py_UCS1;
  Py_UCS2 = uint16_t;
  PPy_UCS2 = ^Py_UCS2;
  Py_UCS4 = uint32_t;
  PPy_UCS4 = ^Py_UCS4;

const
  {/* Состояния интернирования строк Unicode:
     SSTATE_NOT_INTERNED (0): строка не интернирована
     SSTATE_INTERNED_MORTAL (1): строка интернирована, но может быть удалена
     SSTATE_INTERNED_IMMORTAL (2): строка интернирована и бессмертна
     SSTATE_INTERNED_IMMORTAL_STATIC (3): строка интернирована, бессмертна и статична */}
  SSTATE_NOT_INTERNED = 0;
  SSTATE_INTERNED_MORTAL = 1;
  SSTATE_INTERNED_IMMORTAL = 2;
  SSTATE_INTERNED_IMMORTAL_STATIC = 3;

type
  {* Возвращаемые значения функции PyUnicode_KIND(): *}
  PyUnicodeKind = (
    PyUnicode_1BYTE_KIND = 1,
    PyUnicode_2BYTE_KIND = 2,
    PyUnicode_4BYTE_KIND = 4
    );

  P_PyUnicodeObject_state = ^_PyUnicodeObject_state;

  _PyUnicodeObject_state = bitpacked record
  {/* Если значение interned не равно нулю, две ссылки из
  словаря на этот объект * не * учитываются в ob_refcnt .
  Возможные значения здесь:
       0: Not Interned
       1: Interned
       2: Interned and Immortal
       3: Interned, Immortal, and Static
  Эта классификация позволяет среде выполнения определить правильный
  механизм очистки при завершении работы среды выполнения. */}
    {$IFDEF Py_GIL_DISABLED}
    //Доступ к нему должен осуществляться атомарно, поэтому это не может быть битовое поле.
    interned: byte; //8
    {$ELSE}
    interned: 0..3; //2
    {$ENDIF}
      {/* Размер символа:

       - PyUnicode_1BYTE_KIND (1):

         * тип символа = Py_UCS1 (8 бит, без знака)
         * все символы находятся в диапазоне U+0000-U+00FF (latin1)
         * если установлен ascii, все символы находятся в диапазоне U+0000-U+007F
         (ASCII), в противном случае хотя бы один символ находится в диапазоне
         U+0080-U+00FF

       - PyUnicode_2BYTE_KIND (2):

         * тип символа = Py_UCS2 (16 бит, без знака)
         * все символы находятся в диапазоне U+0000-U+FFFF (BMP)
         * хотя бы один символ находится в диапазоне U+0100-U+FFFF

       - PyUnicode_4BYTE_KIND (4):

         * тип символа = Py_UCS4 (32 бита, без знака)
         * все символы находятся в диапазоне U+0000-U+10FFFF
         * по крайней мере, один символ находится в диапазоне U+10000-U+10FFFF}
    kind: 0..7; //3
      {/* Compact - это по отношению к схеме распределения. Компактные объекты unicode
       требуют только один блок памяти, в то время как некомпактные объекты используют
       один блок для структуры PyUnicodeObject и другой для буфера данных. */}
    compact: 0..1; //1
      {/* Строка содержит только символы в диапазоне U+0000-U+007F (ASCII)
       и имеет вид PyUnicode_1BYTE_KIND. Если задан ascii и установлен параметр compact,
       используйте структуру PyASCIIObject. */}
    ascii: 0..1; //1
    {/* Объект распределен статически. */}
    statically_allocated: 0..1; //1
    {$IFDEF Py_GIL_DISABLED}
       {/* Исторический: отступ для обеспечения того, чтобы PyUnicode_DATA()
         всегда был выровнен до 4 байт (см. проблему gh-63736 на m68k) */}
    unsigned_int: 0..24; //24
    {$ENDIF}
  end;

  {$PUSH}
  {$ALIGN 4}//* Обеспечивание выравнивание на 4 байта для PyUnicode_DATA(),
  //* см. gh-63736 на m68k. */
  PPyASCIIObject = ^PyASCIIObject;
  {/* Строки только для ASCII, созданные с помощью PyUnicode_New, используют
   структуру PyASCIIObject. state.ascii и state.compact заданы, и данные
   сразу следуют за структурой. Значение utf8_length можно найти
   в поле length; указатель utf8 равен указателю данных. */}
  PyASCIIObject = record
          {/* Существует 3 формы строк в Юникоде:

       - compact ascii:

         * структура = PyASCIIObject
         * тест: PyUnicode_IS_COMPACT_ASCII(op)
         * kind = PyUnicode_1BYTE_KIND
         * compact = 1
         * ascii = 1
         * (length - это length utf8)
         * (данные начинаются сразу после структуры)
         * (поскольку ASCII декодируется из UTF-8, строка utf8 является данными)

       - compact:

         * структура = PyCompactUnicodeObject
         * тест: IsCompact(Op) and not IsAscii(Op)
         * вид = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND или
          PyUnicode_4BYTE_KIND
         * compact = 1
         * ascii = 0
         * utf8 не используется совместно с данными
         * utf8_length = 0, если utf8 равно НУЛЮ
         * (данные начинаются сразу после структуры)

       - устаревшая строка:

         * structure = структура PyUnicodeObject
         * тест: not PyUnicode_IS_COMPACT(op)
         * вид = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND или
          PyUnicode_4BYTE_KIND
         * компактный = 0
         * data.any не равно НУЛЮ
         * utf8 является общим и utf8_length = длина с данными.any, если ascii = 1
         * utf8_length = 0, если utf8 равно НУЛЮ

       Компактные строки используют только один блок памяти (структура + символы),
      тогда как устаревшие строки используют один блок для структуры и один блок
       для символов.

       Устаревшие строки создаются подклассами Unicode.

       Смотрите также _PyUnicode_CheckConsistency().
    */}
    ob_base: PyObject;
    //* Количество кодовых точек в строке */
    length: Py_ssize_t;
    //* Хэш -1, если не установлен */
    hash: Py_hash_t;
    state: _PyUnicodeObject_state;
  end;


  PPyCompactUnicodeObject = ^PyCompactUnicodeObject;
  {/* Строки, отличные от ASCII, задаются через PyUnicode_New, и используют
   структуру PyCompactUnicodeObject.state.compact, и данные
   сразу следуют за структурой. */}
  PyCompactUnicodeObject = record
    _base: PyASCIIObject;
    {* Количество байтов в utf8, исключая завершающий символ \\0. *}
    utf8_length: Py_ssize_t;
    {* Представление в формате UTF-8 (завершается нулем) *}
    utf8: pansichar;
  end;

  PPyUnicodeObject = ^PyUnicodeObject;

  PyUnicodeObject = record
    base: PyCompactUnicodeObject;
      {/* Канонический буфер Unicode  */}
    case integer of
      0: (any: Pointer);
      1: (latin1: PPy_UCS1);
      2: (ucs2: PPy_UCS2);
      3: (ucs4: PPy_UCS4);
  end;

  {/* Диапазоны суррогатов в Unicode:
     Высокий суррогат: U+D800..U+DBFF
     Низкий суррогат: U+DC00..U+DFFF */}
const
  Py_UNICODE_HIGH_SURROGATE_START = $D800;
  Py_UNICODE_HIGH_SURROGATE_END = $DBFF;
  Py_UNICODE_LOW_SURROGATE_START = $DC00;
  Py_UNICODE_LOW_SURROGATE_END = $DFFF;
  Py_UNICODE_SURROGATE_START = Py_UNICODE_HIGH_SURROGATE_START;
  Py_UNICODE_SURROGATE_END = Py_UNICODE_LOW_SURROGATE_END;

  // Макросы для приведения типов (Type Casting Macros)

{/* Приведение указателя на PyObject к указателю на PyASCIIObject */}
function _PyASCIIObject_CAST(op: PPyObject): PPyASCIIObject; inline;
{/* Приведение указателя на PyObject к указателю на PyCompactUnicodeObject */}
function _PyCompactUnicodeObject_CAST(op: PPyObject): PPyCompactUnicodeObject; inline;
{/* Приведение указателя на PyObject к указателю на PyUnicodeObject */}
function _PyUnicodeObject_CAST(op: PPyObject): PPyUnicodeObject; inline;

// Макросы для проверки типов строк (String Type Check Macros)

{/* Проверяет, является ли строка компактной ASCII строкой.
   Возвращает true, если state.compact и state.ascii установлены. */}
function PyUnicode_IS_COMPACT_ASCII(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка компактной (не устаревшей).
   Возвращает true, если state.compact установлен. */}
function PyUnicode_IS_COMPACT(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка ASCII строкой.
   Возвращает true, если state.ascii установлен. */}
function PyUnicode_IS_ASCII(unicode: PPyObject): cbool; inline;
{/* Проверяет, готова ли строка к использованию.
   Возвращает true, если строка компактна или данные не равны NULL. */}
function PyUnicode_IS_READY(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка компактной и ASCII одновременно.
   Эквивалентно PyUnicode_IS_COMPACT(op) and PyUnicode_IS_ASCII(op). */}
function PyUnicode_IS_COMPACT_AND_ASCII(op: PPyObject): cbool; inline;

// Макросы для получения данных (Data Access Macros)

{/* Возвращает вид (kind) строки Unicode: 1, 2 или 4 байта на символ. */}
function PyUnicode_KIND(unicode: PPyObject): PyUnicodeKind; inline;
{/* Возвращает длину строки в кодовых точках. */}
function PyUnicode_GET_LENGTH(op: PPyObject): Py_ssize_t; inline;
{/* Возвращает длину строки в кодовых точках (алиас для PyUnicode_GET_LENGTH). */}
function PyUnicode_LENGTH(op: PPyObject): Py_ssize_t; inline;
{/* Возвращает указатель на данные строки Unicode.
   Для компактных строк данные следуют сразу после структуры.
   Для устаревших строк возвращает data.any. */}
function PyUnicode_DATA(op: PPyObject): Pointer; inline;
{/* Возвращает указатель на данные для строки с 1-байтовыми символами (Py_UCS1). */}
function PyUnicode_1BYTE_DATA(op: PPyObject): PPy_UCS1; inline;
{/* Возвращает указатель на данные для строки с 2-байтовыми символами (Py_UCS2). */}
function PyUnicode_2BYTE_DATA(op: PPyObject): PPy_UCS2; inline;
{/* Возвращает указатель на данные для строки с 4-байтовыми символами (Py_UCS4). */}
function PyUnicode_4BYTE_DATA(op: PPyObject): PPy_UCS4; inline;
{/* Возвращает размер данных строки в байтах. */}
function PyUnicode_GET_DATA_SIZE(op: PPyObject): Py_ssize_t; inline;
{/* Возвращает максимальное значение символа в строке на основе вида. */}
function PyUnicode_MAX_CHAR_VALUE(op: PPyObject): Py_UCS4; inline;

// Макросы для чтения символов (Character Reading Macros)
{/* Читает символ по индексу i из строки с указанным видом kind.
   kind должен быть PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND или PyUnicode_4BYTE_KIND. */}
function PyUnicode_READ(kind: PyUnicodeKind; Data: Pointer;
  i: Py_ssize_t): Py_UCS4; inline;
{/* Читает символ по индексу i из строки, автоматически определяя вид. */}
function PyUnicode_READ_CHAR(op: PPyObject; i: Py_ssize_t): Py_UCS4; inline;
{/* Читает символ по индексу i из строки с указанным видом kind.
   kind должен быть PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND или PyUnicode_4BYTE_KIND. */}
function PyUnicode_READ_KIND(op: PPyObject; kind: PyUnicodeKind;
  i: Py_ssize_t): Py_UCS4; inline;
{/* Получает символ по индексу i из строки Unicode.
   Эквивалентно PyUnicode_READ_CHAR. */}
function PyUnicode_GET_CHAR(op: PPyObject; i: Py_ssize_t): Py_UCS4; inline;

// Макросы для работы с UTF-8

{/* Возвращает указатель на UTF-8 представление строки.
   Для ASCII строк возвращает указатель на данные.
   Для компактных не-ASCII строк возвращает utf8, если оно не NULL.
   Для устаревших строк возвращает utf8, если оно не NULL. */}
function PyUnicode_UTF8(op: PPyObject): pansichar; inline;
{/* Возвращает длину UTF-8 представления в байтах (без завершающего нуля). */}
function PyUnicode_UTF8_LENGTH(op: PPyObject): Py_ssize_t; inline;
{/* Возвращает длину UTF-8 представления в байтах (алиас для PyUnicode_UTF8_LENGTH). */}
function PyUnicode_GET_UTF8_LENGTH(op: PPyObject): Py_ssize_t; inline;
{/* Возвращает размер UTF-8 представления в байтах (включая завершающий нуль). */}
function PyUnicode_UTF8_SIZE(op: PPyObject): Py_ssize_t; inline;
{/* Проверяет, является ли строка статически распределенной.
   Возвращает true, если state.statically_allocated установлен. */}
function PyUnicode_IS_STATIC(op: PPyObject): cbool; inline;
{/* Проверяет, интернирована ли строка.
   Возвращает true, если state.interned не равен SSTATE_NOT_INTERNED. */}
function PyUnicode_IS_INTERNED(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка интернированной смертной (mortal).
   Возвращает true, если state.interned равен SSTATE_INTERNED_MORTAL. */}
function PyUnicode_IS_INTERNED_MORTAL(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка интернированной бессмертной (immortal).
   Возвращает true, если state.interned равен SSTATE_INTERNED_IMMORTAL. */}
function PyUnicode_IS_INTERNED_IMMORTAL(op: PPyObject): cbool; inline;
{/* Проверяет, является ли строка интернированной статической (static).
   Возвращает true, если state.interned равен SSTATE_INTERNED_IMMORTAL_STATIC. */}
function PyUnicode_IS_INTERNED_STATIC(op: PPyObject): cbool; inline;

// Функции для работы с суррогатами (Surrogate Functions)

{/* Проверяет, является ли символ суррогатом (высоким или низким).
   Суррогаты находятся в диапазоне U+D800..U+DFFF. */}
function Py_UNICODE_IS_SURROGATE(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ высоким суррогатом.
   Высокие суррогаты находятся в диапазоне U+D800..U+DBFF. */}
function Py_UNICODE_IS_HIGH_SURROGATE(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ низким суррогатом.
   Низкие суррогаты находятся в диапазоне U+DC00..U+DFFF. */}
function Py_UNICODE_IS_LOW_SURROGATE(ch: Py_UCS4): cbool; inline;
{/* Объединяет высокий и низкий суррогаты в одну кодовую точку.
   high должен быть высоким суррогатом, low - низким суррогатом.
   Возвращает кодовую точку в диапазоне U+10000..U+10FFFF. */}
function Py_UNICODE_JOIN_SURROGATES(high: Py_UCS4; low: Py_UCS4): Py_UCS4; inline;
{/* Извлекает высокий суррогат из кодовой точки.
   ch должна быть в диапазоне U+10000..U+10FFFF.
   Возвращает высокий суррогат в диапазоне U+D800..U+DBFF. */}
function Py_UNICODE_HIGH_SURROGATE(ch: Py_UCS4): Py_UCS4; inline;
{/* Извлекает низкий суррогат из кодовой точки.
   ch должна быть в диапазоне U+10000..U+10FFFF.
   Возвращает низкий суррогат в диапазоне U+DC00..U+DFFF. */}
function Py_UNICODE_LOW_SURROGATE(ch: Py_UCS4): Py_UCS4; inline;

// Макросы для проверки свойств символов (Character Property Macros)
{/* Проверяет, является ли символ пробельным.
   Использует _PyUnicode_IsWhitespace для не-ASCII символов. */}
function Py_UNICODE_ISSPACE(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ строчной буквой.
   Использует _PyUnicode_IsLowercase. */}
function Py_UNICODE_ISLOWER(ch: Py_UCS4): cbool; inline;
   {/* Проверяет, является ли символ заглавной буквой.
      Использует _PyUnicode_IsUppercase. */}
function Py_UNICODE_ISUPPER(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ буквой в регистре titlecase.
   Использует _PyUnicode_IsTitlecase. */}
function Py_UNICODE_ISTITLE(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ символом переноса строки.
   Использует _PyUnicode_IsLinebreak. */}
function Py_UNICODE_ISLINEBREAK(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ десятичной цифрой.
   Использует _PyUnicode_IsDecimalDigit. */}
function Py_UNICODE_ISDECIMAL(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ цифрой.
   Использует _PyUnicode_IsDigit. */}
function Py_UNICODE_ISDIGIT(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ числовым символом.
   Использует _PyUnicode_IsNumeric. */}
function Py_UNICODE_ISNUMERIC(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ печатаемым.
   Использует _PyUnicode_IsPrintable. */}
function Py_UNICODE_ISPRINTABLE(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ буквой.
   Использует _PyUnicode_IsAlpha. */}
function Py_UNICODE_ISALPHA(ch: Py_UCS4): cbool; inline;
{/* Проверяет, является ли символ буквой или цифрой.
   Эквивалентно Py_UNICODE_ISALPHA(ch) or Py_UNICODE_ISDIGIT(ch). */}
function Py_UNICODE_ISALNUM(ch: Py_UCS4): cbool; inline;

// Макросы для преобразования символов (Character Conversion Macros)

{/* Преобразует символ в строчную букву.
   Использует _PyUnicode_ToLowercase. */}
function Py_UNICODE_TOLOWER(ch: Py_UCS4): Py_UCS4; inline;
{/* Преобразует символ в заглавную букву.
   Использует _PyUnicode_ToUppercase. */}
function Py_UNICODE_TOUPPER(ch: Py_UCS4): Py_UCS4; inline;
{/* Преобразует символ в букву в регистре titlecase.
   Использует _PyUnicode_ToTitlecase. */}
function Py_UNICODE_TOTITLE(ch: Py_UCS4): Py_UCS4; inline;
{/* Преобразует символ в десятичную цифру.
   Использует _PyUnicode_ToDecimalDigit. Возвращает -1, если символ не является десятичной цифрой. */}
function Py_UNICODE_TODECIMAL(ch: Py_UCS4): cint; inline;
{/* Преобразует символ в цифру.
   Использует _PyUnicode_ToDigit. Возвращает -1, если символ не является цифрой. */}
function Py_UNICODE_TODIGIT(ch: Py_UCS4): cint; inline;
{/* Преобразует символ в числовое значение.
   Использует _PyUnicode_ToNumeric. Возвращает -1.0, если символ не является числовым. */}
function Py_UNICODE_TONUMERIC(ch: Py_UCS4): double; inline;

var

  // Статические функции

  PyUnicode_AsUTF8: function(obj: PPyObject): pansichar; cdecl;

implementation

var
  _PyUnicode_IsLowercase: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsUppercase: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsTitlecase: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsWhitespace: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsLinebreak: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_ToLowercase: function(ch: Py_UCS4): Py_UCS4; cdecl;
  _PyUnicode_ToUppercase: function(ch: Py_UCS4): Py_UCS4; cdecl;
  _PyUnicode_ToTitlecase: function(ch: Py_UCS4): Py_UCS4; cdecl;
  _PyUnicode_ToDecimalDigit: function(ch: Py_UCS4): cint; cdecl;
  _PyUnicode_ToDigit: function(ch: Py_UCS4): cint; cdecl;
  _PyUnicode_ToNumeric: function(ch: Py_UCS4): double; cdecl;
  _PyUnicode_IsDecimalDigit: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsDigit: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsNumeric: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsPrintable: function(ch: Py_UCS4): cbool; cdecl;
  _PyUnicode_IsAlpha: function(ch: Py_UCS4): cbool; cdecl;




// Реализация макросов приведения типов
function _PyASCIIObject_CAST(op: PPyObject): PPyASCIIObject; inline;
begin
  Result := PPyASCIIObject(op);
end;

function _PyCompactUnicodeObject_CAST(op: PPyObject): PPyCompactUnicodeObject; inline;
begin
  Result := PPyCompactUnicodeObject(op);
end;

function _PyUnicodeObject_CAST(op: PPyObject): PPyUnicodeObject; inline;
begin
  Result := PPyUnicodeObject(op);
end;

// Реализация макросов проверки типов строк
function PyUnicode_IS_COMPACT_ASCII(op: PPyObject): cbool; inline;
begin
  Result := (PyUnicode_IS_COMPACT(op)) and (PyUnicode_IS_ASCII(op));
end;

function PyUnicode_IS_COMPACT(op: PPyObject): cbool; inline;
begin
  Result := (PPyUnicodeObject(op)^.base._base.state.compact) <> 0;
end;

function PyUnicode_IS_ASCII(unicode: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(unicode)^.base._base.state.ascii <> 0;
end;

function PyUnicode_IS_READY(op: PPyObject): cbool; inline;
begin
  Result := PyUnicode_IS_COMPACT(op) or (PPyUnicodeObject(op)^.any <> nil);
end;

function PyUnicode_IS_COMPACT_AND_ASCII(op: PPyObject): cbool; inline;
begin
  Result := PyUnicode_IS_COMPACT_ASCII(op);
end;

// Реализация макросов получения данных
function PyUnicode_KIND(unicode: PPyObject): PyUnicodeKind; inline;
begin
  Result := PyUnicodeKind(PPyUnicodeObject(unicode)^.base._base.state.kind);
end;

function PyUnicode_GET_LENGTH(op: PPyObject): Py_ssize_t; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.length;
end;

function PyUnicode_LENGTH(op: PPyObject): Py_ssize_t; inline;
begin
  Result := PyUnicode_GET_LENGTH(op);
end;

function PyUnicode_DATA(op: PPyObject): Pointer; inline;
var
  uobj: PPyUnicodeObject;
begin
  uobj := PPyUnicodeObject(op);
  if PyUnicode_IS_COMPACT_ASCII(op) then
    // Для компактных ASCII строк данные следуют сразу после PyASCIIObject
    Result := Pointer(pbyte(@(uobj^.base._base)) + SizeOf(PyASCIIObject))
  else if PyUnicode_IS_COMPACT(op) then
    // Для компактных не-ASCII строк данные следуют сразу после PyCompactUnicodeObject
    Result := Pointer(pbyte(@(uobj^.base)) + SizeOf(PyCompactUnicodeObject))
  else
    // Для устаревших строк используем data.any
    Result := uobj^.any;
end;

function PyUnicode_1BYTE_DATA(op: PPyObject): PPy_UCS1; inline;
begin
  Result := PPy_UCS1(PyUnicode_DATA(op));
end;

function PyUnicode_2BYTE_DATA(op: PPyObject): PPy_UCS2; inline;
begin
  Result := PPy_UCS2(PyUnicode_DATA(op));
end;

function PyUnicode_4BYTE_DATA(op: PPyObject): PPy_UCS4; inline;
begin
  Result := PPy_UCS4(PyUnicode_DATA(op));
end;

function PyUnicode_GET_DATA_SIZE(op: PPyObject): Py_ssize_t; inline;
begin
  case PyUnicode_KIND(op) of
    PyUnicode_1BYTE_KIND: Result := PyUnicode_GET_LENGTH(op) * SizeOf(Py_UCS1);
    PyUnicode_2BYTE_KIND: Result := PyUnicode_GET_LENGTH(op) * SizeOf(Py_UCS2);
    PyUnicode_4BYTE_KIND: Result := PyUnicode_GET_LENGTH(op) * SizeOf(Py_UCS4);
    else
      Result := 0;
  end;
end;

function PyUnicode_MAX_CHAR_VALUE(op: PPyObject): Py_UCS4; inline;
begin
  case PyUnicode_KIND(op) of
    PyUnicode_1BYTE_KIND: Result := $FF;
    PyUnicode_2BYTE_KIND: Result := $FFFF;
    PyUnicode_4BYTE_KIND: Result := $10FFFF;
    else
      Result := 0;
  end;
end;

// Реализация макросов чтения символов
function PyUnicode_READ(kind: PyUnicodeKind; Data: Pointer;
  i: Py_ssize_t): Py_UCS4; inline;
begin
  case kind of
    PyUnicode_1BYTE_KIND: Result := PPy_UCS1(Data)[i];
    PyUnicode_2BYTE_KIND: Result := PPy_UCS2(Data)[i];
    PyUnicode_4BYTE_KIND: Result := PPy_UCS4(Data)[i];
    else
      Result := 0;
  end;
end;

function PyUnicode_READ_CHAR(op: PPyObject; i: Py_ssize_t): Py_UCS4; inline;
begin
  Result := PyUnicode_READ(PyUnicode_KIND(op), PyUnicode_DATA(op), i);
end;

function PyUnicode_READ_KIND(op: PPyObject; kind: PyUnicodeKind;
  i: Py_ssize_t): Py_UCS4; inline;
var
  Data: Pointer;
begin
  Data := PyUnicode_DATA(op);
  Result := PyUnicode_READ(kind, Data, i);
end;

function PyUnicode_GET_CHAR(op: PPyObject; i: Py_ssize_t): Py_UCS4; inline;
begin
  Result := PyUnicode_READ_CHAR(op, i);
end;

// Реализация макросов для работы с UTF-8
function PyUnicode_UTF8(op: PPyObject): pansichar; inline;
var
  uobj: PPyUnicodeObject;
begin
  uobj := PPyUnicodeObject(op);
  if PyUnicode_IS_COMPACT_ASCII(op) then
    // Для ASCII строк UTF-8 представление совпадает с данными
    Result := pansichar(PyUnicode_1BYTE_DATA(op))
  else if PyUnicode_IS_COMPACT(op) then
    // Для компактных не-ASCII строк используем utf8
    Result := uobj^.base.utf8
  else
    // Для устаревших строк используем utf8
    Result := uobj^.base.utf8;
end;

function PyUnicode_UTF8_LENGTH(op: PPyObject): Py_ssize_t; inline;
var
  uobj: PPyUnicodeObject;
begin
  uobj := PPyUnicodeObject(op);
  if PyUnicode_IS_COMPACT_ASCII(op) then
    // Для ASCII строк длина UTF-8 равна длине строки
    Result := PyUnicode_GET_LENGTH(op)
  else
    // Для других строк используем utf8_length
    Result := uobj^.base.utf8_length;
end;

function PyUnicode_GET_UTF8_LENGTH(op: PPyObject): Py_ssize_t; inline;
begin
  Result := PyUnicode_UTF8_LENGTH(op);
end;

function PyUnicode_UTF8_SIZE(op: PPyObject): Py_ssize_t; inline;
begin
  Result := PyUnicode_UTF8_LENGTH(op) + 1; // +1 для завершающего нуля
end;

function PyUnicode_IS_STATIC(op: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.state.statically_allocated <> 0;
end;

function PyUnicode_IS_INTERNED(op: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.state.interned <> SSTATE_NOT_INTERNED;
end;

function PyUnicode_IS_INTERNED_MORTAL(op: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.state.interned = SSTATE_INTERNED_MORTAL;
end;

function PyUnicode_IS_INTERNED_IMMORTAL(op: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.state.interned = SSTATE_INTERNED_IMMORTAL;
end;

function PyUnicode_IS_INTERNED_STATIC(op: PPyObject): cbool; inline;
begin
  Result := PPyUnicodeObject(op)^.base._base.state.interned =
    SSTATE_INTERNED_IMMORTAL_STATIC;
end;

// Реализация функций для работы с суррогатами
function Py_UNICODE_IS_SURROGATE(ch: Py_UCS4): cbool; inline;
begin
  Result := (ch >= Py_UNICODE_SURROGATE_START) and (ch <= Py_UNICODE_SURROGATE_END);
end;

function Py_UNICODE_IS_HIGH_SURROGATE(ch: Py_UCS4): cbool; inline;
begin
  Result := (ch >= Py_UNICODE_HIGH_SURROGATE_START) and
    (ch <= Py_UNICODE_HIGH_SURROGATE_END);
end;

function Py_UNICODE_IS_LOW_SURROGATE(ch: Py_UCS4): cbool; inline;
begin
  Result := (ch >= Py_UNICODE_LOW_SURROGATE_START) and
    (ch <= Py_UNICODE_LOW_SURROGATE_END);
end;

function Py_UNICODE_JOIN_SURROGATES(high: Py_UCS4; low: Py_UCS4): Py_UCS4; inline;
begin
  // Объединение суррогатов: ((high - 0xD800) << 10) + (low - 0xDC00) + 0x10000
  Result := ((high - Py_UNICODE_HIGH_SURROGATE_START) shl 10) +
    (low - Py_UNICODE_LOW_SURROGATE_START) + $10000;
end;

function Py_UNICODE_HIGH_SURROGATE(ch: Py_UCS4): Py_UCS4; inline;
begin
  // Извлечение высокого суррогата: ((ch - 0x10000) >> 10) + 0xD800
  Result := ((ch - $10000) shr 10) + Py_UNICODE_HIGH_SURROGATE_START;
end;

function Py_UNICODE_LOW_SURROGATE(ch: Py_UCS4): Py_UCS4; inline;
begin
  // Извлечение низкого суррогата: ((ch - 0x10000) & 0x3FF) + 0xDC00
  Result := ((ch - $10000) and $3FF) + Py_UNICODE_LOW_SURROGATE_START;
end;

// Реализация макросов проверки свойств символов
function Py_UNICODE_ISSPACE(ch: Py_UCS4): cbool; inline;
begin
  // Для ASCII символов используем быструю проверку
  if ch <= $7F then
    //    Result := (ch = $20) or ((ch >= $09) and (ch <= $0D))
    Result := ch in [$20, $09..$0D]
  // пробел, табуляция, перевод строки и т.д.
  else
    Result := _PyUnicode_IsWhitespace(ch);
end;

function Py_UNICODE_ISLOWER(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    //Result := (ch >= Ord('a')) and (ch <= Ord('z'))
    Result := ch in [Ord('a'), Ord('z')]
  else
    Result := _PyUnicode_IsLowercase(ch);
end;

function Py_UNICODE_ISUPPER(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    //    Result := (ch >= Ord('A')) and (ch <= Ord('Z'))
    Result := ch in [Ord('A')..Ord('Z')]
  else
    Result := _PyUnicode_IsUppercase(ch);
end;

function Py_UNICODE_ISTITLE(ch: Py_UCS4): cbool; inline;
begin
  Result := _PyUnicode_IsTitlecase(ch);
end;

function Py_UNICODE_ISLINEBREAK(ch: Py_UCS4): cbool; inline;
begin
  Result := _PyUnicode_IsLinebreak(ch);
end;

function Py_UNICODE_ISDECIMAL(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    Result := (ch >= Ord('0')) and (ch <= Ord('9'))
  else
    Result := _PyUnicode_IsDecimalDigit(ch);
end;

function Py_UNICODE_ISDIGIT(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    Result := (ch >= Ord('0')) and (ch <= Ord('9'))
  else
    Result := _PyUnicode_IsDigit(ch);
end;

function Py_UNICODE_ISNUMERIC(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    Result := (ch >= Ord('0')) and (ch <= Ord('9'))
  else
    Result := _PyUnicode_IsNumeric(ch);
end;

function Py_UNICODE_ISPRINTABLE(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    // ASCII печатаемые символы: от 0x20 (пробел) до 0x7E (~)
    Result := (ch >= $20) and (ch <= $7E)
  else
    Result := _PyUnicode_IsPrintable(ch);
end;

function Py_UNICODE_ISALPHA(ch: Py_UCS4): cbool; inline;
begin
  if ch <= $7F then
    Result := ((ch >= Ord('a')) and (ch <= Ord('z'))) or
      ((ch >= Ord('A')) and (ch <= Ord('Z')))
  else
    Result := _PyUnicode_IsAlpha(ch);
end;

function Py_UNICODE_ISALNUM(ch: Py_UCS4): cbool; inline;
begin
  Result := Py_UNICODE_ISALPHA(ch) or Py_UNICODE_ISDIGIT(ch);
end;

// Реализация макросов преобразования символов
function Py_UNICODE_TOLOWER(ch: Py_UCS4): Py_UCS4; inline;
begin
  if ch <= $7F then
  begin
    if (ch >= Ord('A')) and (ch <= Ord('Z')) then
      Result := ch + (Ord('a') - Ord('A'))
    else
      Result := ch;
  end
  else
    Result := _PyUnicode_ToLowercase(ch);
end;

function Py_UNICODE_TOUPPER(ch: Py_UCS4): Py_UCS4; inline;
begin
  if ch <= $7F then
  begin
    if ch in  [Ord('a')..Ord('z')] then
      Result := ch - (Ord('a') - Ord('A'))
    else
      Result := ch;
  end
  else
    Result := _PyUnicode_ToUppercase(ch);
end;

function Py_UNICODE_TOTITLE(ch: Py_UCS4): Py_UCS4; inline;
begin
  Result := _PyUnicode_ToTitlecase(ch);
end;

function Py_UNICODE_TODECIMAL(ch: Py_UCS4): cint; inline;
begin
  if ch <= $7F then
  begin
    if ch in [Ord('0')..Ord('9')] then
      Result := ch - Ord('0')
    else
      Result := -1;
  end
  else
    Result := _PyUnicode_ToDecimalDigit(ch);
end;

function Py_UNICODE_TODIGIT(ch: Py_UCS4): integer; inline;
begin
  if ch <= $7F then
  begin
    if ch in [Ord('0')..Ord('9')] then
      Result := ch - Ord('0')
    else
      Result := -1;
  end
  else
    Result := _PyUnicode_ToDigit(ch);
end;

function Py_UNICODE_TONUMERIC(ch: Py_UCS4): double; inline;
begin
  if ch <= $7F then
  begin
    if ch in [Ord('0')..Ord('9')] then
      Result := ch - Ord('0')
    else
      Result := -1.0;
  end
  else
    Result := _PyUnicode_ToNumeric(ch);
end;


initialization

  // Инициализация внешних функций

  Pointer(PyUnicode_AsUTF8) := getProc('PyUnicode_AsUTF8');
  Pointer(_PyUnicode_IsLowercase) := getProc('_PyUnicode_IsLowercase');
  Pointer(_PyUnicode_IsUppercase) := getProc('_PyUnicode_IsUppercase');
  Pointer(_PyUnicode_IsTitlecase) := getProc('_PyUnicode_IsTitlecase');
  Pointer(_PyUnicode_IsWhitespace) := getProc('_PyUnicode_IsWhitespace');
  Pointer(_PyUnicode_IsLinebreak) := getProc('_PyUnicode_IsLinebreak');
  Pointer(_PyUnicode_ToLowercase) := getProc('_PyUnicode_ToLowercase');
  Pointer(_PyUnicode_ToUppercase) := getProc('_PyUnicode_ToUppercase');
  Pointer(_PyUnicode_ToTitlecase) := getProc('_PyUnicode_ToTitlecase');
  Pointer(_PyUnicode_ToDecimalDigit) := getProc('_PyUnicode_ToDecimalDigit');
  Pointer(_PyUnicode_ToDigit) := getProc('_PyUnicode_ToDigit');
  Pointer(_PyUnicode_ToNumeric) := getProc('_PyUnicode_ToNumeric');
  Pointer(_PyUnicode_IsDecimalDigit) := getProc('_PyUnicode_IsDecimalDigit');
  Pointer(_PyUnicode_IsDigit) := getProc('_PyUnicode_IsDigit');
  Pointer(_PyUnicode_IsNumeric) := getProc('_PyUnicode_IsNumeric');
  Pointer(_PyUnicode_IsPrintable) := getProc('_PyUnicode_IsPrintable');
  Pointer(_PyUnicode_IsAlpha) := getProc('_PyUnicode_IsAlpha');
end.
